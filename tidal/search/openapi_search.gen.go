// Package tidal_search provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package tidal_search

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	Authorization_Code_PKCEScopes = "Authorization_Code_PKCE.Scopes"
	Client_CredentialsScopes      = "Client_Credentials.Scopes"
)

// Defines values for AlbumsAttributesAvailability.
const (
	AlbumsAttributesAvailabilityDJ     AlbumsAttributesAvailability = "DJ"
	AlbumsAttributesAvailabilitySTEM   AlbumsAttributesAvailability = "STEM"
	AlbumsAttributesAvailabilitySTREAM AlbumsAttributesAvailability = "STREAM"
)

// Defines values for AlbumsAttributesType.
const (
	ALBUM  AlbumsAttributesType = "ALBUM"
	EP     AlbumsAttributesType = "EP"
	SINGLE AlbumsAttributesType = "SINGLE"
)

// Defines values for ExternalLinkMetaType.
const (
	FACEBOOK             ExternalLinkMetaType = "FACEBOOK"
	HOMEPAGE             ExternalLinkMetaType = "HOMEPAGE"
	INSTAGRAM            ExternalLinkMetaType = "INSTAGRAM"
	SNAPCHAT             ExternalLinkMetaType = "SNAPCHAT"
	TIDALAUTOPLAYANDROID ExternalLinkMetaType = "TIDAL_AUTOPLAY_ANDROID"
	TIDALAUTOPLAYIOS     ExternalLinkMetaType = "TIDAL_AUTOPLAY_IOS"
	TIDALAUTOPLAYWEB     ExternalLinkMetaType = "TIDAL_AUTOPLAY_WEB"
	TIDALSHARING         ExternalLinkMetaType = "TIDAL_SHARING"
	TIKTOK               ExternalLinkMetaType = "TIKTOK"
	TWITTER              ExternalLinkMetaType = "TWITTER"
)

// Defines values for TracksAttributesAvailability.
const (
	TracksAttributesAvailabilityDJ     TracksAttributesAvailability = "DJ"
	TracksAttributesAvailabilitySTEM   TracksAttributesAvailability = "STEM"
	TracksAttributesAvailabilitySTREAM TracksAttributesAvailability = "STREAM"
)

// Defines values for VideosAttributesAvailability.
const (
	DJ     VideosAttributesAvailability = "DJ"
	STEM   VideosAttributesAvailability = "STEM"
	STREAM VideosAttributesAvailability = "STREAM"
)

// AlbumsAttributes defines model for Albums_Attributes.
type AlbumsAttributes struct {
	// Availability Defines an album availability e.g. for streaming, DJs, stems
	Availability *[]AlbumsAttributesAvailability `json:"availability,omitempty"`

	// BarcodeId Barcode id (EAN-13 or UPC-A)
	BarcodeId string `json:"barcodeId"`

	// Copyright Copyright information
	Copyright *string `json:"copyright,omitempty"`

	// Duration Duration (ISO-8601)
	Duration string `json:"duration"`

	// Explicit Indicates whether an album consist of any explicit content
	Explicit bool `json:"explicit"`

	// ExternalLinks Represents available links to something that is related to an album resource, but external to the TIDAL API
	ExternalLinks *[]CatalogueItemExternalLink `json:"externalLinks,omitempty"`

	// ImageLinks Represents available links to, and metadata about, an album cover images
	ImageLinks *[]CatalogueItemImageLink `json:"imageLinks,omitempty"`
	MediaTags  []string                  `json:"mediaTags"`

	// NumberOfItems Number of album items
	NumberOfItems int32 `json:"numberOfItems"`

	// NumberOfVolumes Number of volumes
	NumberOfVolumes int32 `json:"numberOfVolumes"`

	// Popularity Album popularity (ranged in 0.00 ... 1.00). Conditionally visible
	Popularity float64 `json:"popularity"`

	// ReleaseDate Release date (ISO-8601)
	ReleaseDate *openapi_types.Date `json:"releaseDate,omitempty"`

	// Title Original title
	Title string `json:"title"`

	// Type Album type, e.g. single, regular album, or extended play
	Type AlbumsAttributesType `json:"type"`

	// VideoLinks Represents available links to, and metadata about, an album cover videos
	VideoLinks *[]CatalogueItemVideoLink `json:"videoLinks,omitempty"`
}

// AlbumsAttributesAvailability defines model for AlbumsAttributes.Availability.
type AlbumsAttributesAvailability string

// AlbumsAttributesType Album type, e.g. single, regular album, or extended play
type AlbumsAttributesType string

// AlbumsItemsMultiDataRelationshipDocument defines model for Albums_Items_Multi_Data_Relationship_Document.
type AlbumsItemsMultiDataRelationshipDocument struct {
	Data *[]AlbumsItemsResourceIdentifier `json:"data,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// AlbumsItemsResourceIdentifier Resource identifier JSON:API object
type AlbumsItemsResourceIdentifier struct {
	// Id resource unique identifier
	Id   string                             `json:"id"`
	Meta *AlbumsItemsResourceIdentifierMeta `json:"meta,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// AlbumsItemsResourceIdentifierMeta defines model for Albums_Items_Resource_Identifier_Meta.
type AlbumsItemsResourceIdentifierMeta struct {
	// TrackNumber track number
	TrackNumber int32 `json:"trackNumber"`

	// VolumeNumber volume number
	VolumeNumber int32 `json:"volumeNumber"`
}

// AlbumsRelationships defines model for Albums_Relationships.
type AlbumsRelationships struct {
	Artists       MultiDataRelationshipDoc                 `json:"artists"`
	Items         AlbumsItemsMultiDataRelationshipDocument `json:"items"`
	Providers     MultiDataRelationshipDoc                 `json:"providers"`
	SimilarAlbums MultiDataRelationshipDoc                 `json:"similarAlbums"`
}

// AlbumsResource defines model for Albums_Resource.
type AlbumsResource struct {
	Attributes *AlbumsAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links               `json:"links,omitempty"`
	Relationships *AlbumsRelationships `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// ArtistRole defines model for Artist_Role.
type ArtistRole struct {
	Id   *string `json:"id,omitempty"`
	Name *string `json:"name,omitempty"`
}

// ArtistsAttributes defines model for Artists_Attributes.
type ArtistsAttributes struct {
	// ExternalLinks Represents available links to something that is related to an artist resource, but external to the TIDAL API
	ExternalLinks *[]CatalogueItemExternalLink `json:"externalLinks,omitempty"`

	// ImageLinks Represents available links to, and metadata about, an artist images
	ImageLinks *[]CatalogueItemImageLink `json:"imageLinks,omitempty"`

	// Name Artist name
	Name string `json:"name"`

	// Popularity Artist popularity (ranged in 0.00 ... 1.00). Conditionally visible
	Popularity float64 `json:"popularity"`

	// Roles Artist roles
	Roles *[]ArtistRole `json:"roles,omitempty"`
}

// ArtistsRelationships defines model for Artists_Relationships.
type ArtistsRelationships struct {
	Albums         MultiDataRelationshipDoc                           `json:"albums"`
	Radio          MultiDataRelationshipDoc                           `json:"radio"`
	SimilarArtists MultiDataRelationshipDoc                           `json:"similarArtists"`
	TrackProviders ArtistsTrackProvidersMultiDataRelationshipDocument `json:"trackProviders"`
	Tracks         MultiDataRelationshipDoc                           `json:"tracks"`
	Videos         MultiDataRelationshipDoc                           `json:"videos"`
}

// ArtistsResource defines model for Artists_Resource.
type ArtistsResource struct {
	Attributes *ArtistsAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links                `json:"links,omitempty"`
	Relationships *ArtistsRelationships `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// ArtistsTrackProvidersMultiDataRelationshipDocument defines model for Artists_TrackProviders_Multi_Data_Relationship_Document.
type ArtistsTrackProvidersMultiDataRelationshipDocument struct {
	Data *[]ArtistsTrackProvidersResourceIdentifier `json:"data,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// ArtistsTrackProvidersResourceIdentifier Resource identifier JSON:API object
type ArtistsTrackProvidersResourceIdentifier struct {
	// Id resource unique identifier
	Id   string                                       `json:"id"`
	Meta *ArtistsTrackProvidersResourceIdentifierMeta `json:"meta,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// ArtistsTrackProvidersResourceIdentifierMeta defines model for Artists_TrackProviders_Resource_Identifier_Meta.
type ArtistsTrackProvidersResourceIdentifierMeta struct {
	// NumberOfTracks total number of tracks released together with the provider
	NumberOfTracks int64 `json:"numberOfTracks"`
}

// CatalogueItemExternalLink defines model for Catalogue_Item_External_Link.
type CatalogueItemExternalLink struct {
	// Href link to something that is related to a resource
	Href string `json:"href"`

	// Meta metadata about an external link
	Meta ExternalLinkMeta `json:"meta"`
}

// CatalogueItemImageLink defines model for Catalogue_Item_Image_Link.
type CatalogueItemImageLink struct {
	// Href link to an image
	Href string `json:"href"`

	// Meta metadata about an image
	Meta ImageLinkMeta `json:"meta"`
}

// CatalogueItemVideoLink defines model for Catalogue_Item_Video_Link.
type CatalogueItemVideoLink struct {
	// Href link to a video
	Href string `json:"href"`

	// Meta metadata about a video
	Meta VideoLinkMeta `json:"meta"`
}

// ErrorDocument JSON:API error document object
type ErrorDocument struct {
	// Errors array of error objects
	Errors *[]ErrorObject `json:"errors,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// ErrorObject JSON:API error object
type ErrorObject struct {
	// Code application-specific error code
	Code *string `json:"code,omitempty"`

	// Detail human-readable explanation specific to this occurrence of the problem
	Detail *string `json:"detail,omitempty"`

	// Id unique identifier for this particular occurrence of the problem
	Id *string `json:"id,omitempty"`

	// Source object containing references to the primary source of the error
	Source *ErrorObjectSource `json:"source,omitempty"`

	// Status HTTP status code applicable to this problem
	Status *string `json:"status,omitempty"`
}

// ErrorObjectSource object containing references to the primary source of the error
type ErrorObjectSource struct {
	// Header string indicating the name of a single request header which caused the error
	Header *string `json:"header,omitempty"`

	// Parameter string indicating which URI query parameter caused the error.
	Parameter *string `json:"parameter,omitempty"`

	// Pointer a JSON Pointer [RFC6901] to the value in the request document that caused the error
	Pointer *string `json:"pointer,omitempty"`
}

// ExternalLinkMeta metadata about an external link
type ExternalLinkMeta struct {
	// Type external link type
	Type ExternalLinkMetaType `json:"type"`
}

// ExternalLinkMetaType external link type
type ExternalLinkMetaType string

// ImageLinkMeta metadata about an image
type ImageLinkMeta struct {
	// Height image height (in pixels)
	Height int32 `json:"height"`

	// Width image width (in pixels)
	Width int32 `json:"width"`
}

// Links Links JSON:API object
type Links struct {
	// Next the next page of data (pagination)
	Next *string `json:"next,omitempty"`

	// Self the link that generated the current response document
	Self string `json:"self"`
}

// MultiDataRelationshipDoc defines model for Multi_Data_Relationship_Doc.
type MultiDataRelationshipDoc struct {
	Data *[]ResourceIdentifier `json:"data,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// PlaylistsAttributes defines model for Playlists_Attributes.
type PlaylistsAttributes struct {
	// Bounded Indicates if the playlist has a duration and set number of tracks
	Bounded bool `json:"bounded"`

	// CreatedAt Datetime of playlist creation (ISO 8601)
	CreatedAt time.Time `json:"createdAt"`

	// Description Playlist description
	Description *string `json:"description,omitempty"`

	// Duration Duration of the playlist expressed in accordance with ISO 8601
	Duration *string `json:"duration,omitempty"`

	// ExternalLinks Sharing links to the playlist
	ExternalLinks []PlaylistsExternalLink `json:"externalLinks"`

	// ImageLinks Images associated with the playlist
	ImageLinks []PlaylistsImageLink `json:"imageLinks"`

	// LastModifiedAt Datetime of last modification of the playlist (ISO 8601)
	LastModifiedAt time.Time `json:"lastModifiedAt"`

	// Name Playlist name
	Name string `json:"name"`

	// NumberOfItems Number of items in the playlist
	NumberOfItems *int32 `json:"numberOfItems,omitempty"`

	// PlaylistType The type of the playlist
	PlaylistType string `json:"playlistType"`

	// Privacy Privacy setting of the playlist
	Privacy string `json:"privacy"`
}

// PlaylistsExternalLink Sharing links to the playlist
type PlaylistsExternalLink struct {
	// Href link to something that is related to a resource
	Href string `json:"href"`

	// Meta metadata about an external link
	Meta ExternalLinkMeta `json:"meta"`
}

// PlaylistsImageLink Images associated with the playlist
type PlaylistsImageLink struct {
	// Href link to an image
	Href string `json:"href"`

	// Meta metadata about an image
	Meta *ImageLinkMeta `json:"meta,omitempty"`
}

// PlaylistsItemsMultiDataRelationshipDocument defines model for Playlists_Items_Multi_Data_Relationship_Document.
type PlaylistsItemsMultiDataRelationshipDocument struct {
	Data *[]PlaylistsItemsResourceIdentifier `json:"data,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// PlaylistsItemsResourceIdentifier Resource identifier JSON:API object
type PlaylistsItemsResourceIdentifier struct {
	// Id resource unique identifier
	Id   string                                `json:"id"`
	Meta *PlaylistsItemsResourceIdentifierMeta `json:"meta,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// PlaylistsItemsResourceIdentifierMeta defines model for Playlists_Items_Resource_Identifier_Meta.
type PlaylistsItemsResourceIdentifierMeta struct {
	// AddedAt When the item was added to the playlist
	AddedAt *time.Time `json:"addedAt,omitempty"`

	// ItemId Unique identifier of the item in a playlist
	ItemId *string `json:"itemId,omitempty"`
}

// PlaylistsRelationships defines model for Playlists_Relationships.
type PlaylistsRelationships struct {
	Items  PlaylistsItemsMultiDataRelationshipDocument `json:"items"`
	Owners MultiDataRelationshipDoc                    `json:"owners"`
}

// PlaylistsResource defines model for Playlists_Resource.
type PlaylistsResource struct {
	Attributes *PlaylistsAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links                  `json:"links,omitempty"`
	Relationships *PlaylistsRelationships `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// ProvidersAttributes defines model for Providers_Attributes.
type ProvidersAttributes struct {
	// Name Provider name. Conditionally visible.
	Name string `json:"name"`
}

// ProvidersResource defines model for Providers_Resource.
type ProvidersResource struct {
	Attributes *ProvidersAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// ResourceObjectObject defines model for ResourceObjectObject.
type ResourceObjectObject struct {
	Attributes *map[string]interface{} `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links                  `json:"links,omitempty"`
	Relationships *map[string]interface{} `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// ResourceIdentifier Resource identifier JSON:API object
type ResourceIdentifier struct {
	// Id resource unique identifier
	Id string `json:"id"`

	// Type resource unique type
	Type string `json:"type"`
}

// SearchresultsAttributes defines model for Searchresults_Attributes.
type SearchresultsAttributes struct {
	// DidYouMean 'did you mean' prompt
	DidYouMean *string `json:"didYouMean,omitempty"`

	// TrackingId search request unique tracking number
	TrackingId string `json:"trackingId"`
}

// SearchresultsMultiDataDocument defines model for Searchresults_Multi_Data_Document.
type SearchresultsMultiDataDocument struct {
	Data     *[]SearchresultsResource                        `json:"data,omitempty"`
	Included *[]SearchresultsMultiDataDocument_Included_Item `json:"included,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// SearchresultsMultiDataDocument_Included_Item defines model for Searchresults_Multi_Data_Document.included.Item.
type SearchresultsMultiDataDocument_Included_Item struct {
	union json.RawMessage
}

// SearchresultsMultiDataRelationshipDocument defines model for Searchresults_Multi_Data_Relationship_Document.
type SearchresultsMultiDataRelationshipDocument struct {
	Data     *[]ResourceIdentifier                                       `json:"data,omitempty"`
	Included *[]SearchresultsMultiDataRelationshipDocument_Included_Item `json:"included,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// SearchresultsMultiDataRelationshipDocument_Included_Item defines model for Searchresults_Multi_Data_Relationship_Document.included.Item.
type SearchresultsMultiDataRelationshipDocument_Included_Item struct {
	union json.RawMessage
}

// SearchresultsRelationships defines model for Searchresults_Relationships.
type SearchresultsRelationships struct {
	Albums    MultiDataRelationshipDoc `json:"albums"`
	Artists   MultiDataRelationshipDoc `json:"artists"`
	Playlists MultiDataRelationshipDoc `json:"playlists"`
	TopHits   MultiDataRelationshipDoc `json:"topHits"`
	Tracks    MultiDataRelationshipDoc `json:"tracks"`
	Videos    MultiDataRelationshipDoc `json:"videos"`
}

// SearchresultsResource defines model for Searchresults_Resource.
type SearchresultsResource struct {
	Attributes *SearchresultsAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links                      `json:"links,omitempty"`
	Relationships *SearchresultsRelationships `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// SearchresultsSingleDataDocument defines model for Searchresults_Single_Data_Document.
type SearchresultsSingleDataDocument struct {
	Data     *SearchresultsResource                           `json:"data,omitempty"`
	Included *[]SearchresultsSingleDataDocument_Included_Item `json:"included,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// SearchresultsSingleDataDocument_Included_Item defines model for Searchresults_Single_Data_Document.included.Item.
type SearchresultsSingleDataDocument_Included_Item struct {
	union json.RawMessage
}

// SingletonDataRelationshipDoc defines model for Singleton_Data_Relationship_Doc.
type SingletonDataRelationshipDoc struct {
	// Data Resource identifier JSON:API object
	Data *ResourceIdentifier `json:"data,omitempty"`

	// Links Links JSON:API object
	Links *Links `json:"links,omitempty"`
}

// TracksAttributes defines model for Tracks_Attributes.
type TracksAttributes struct {
	// Availability Defines a catalog item availability e.g. for streaming, DJs, stems
	Availability *[]TracksAttributesAvailability `json:"availability,omitempty"`

	// Copyright Copyright information
	Copyright *string `json:"copyright,omitempty"`

	// Duration Duration expressed in accordance with ISO 8601
	Duration string `json:"duration"`

	// Explicit Indicates whether a catalog item consist of any explicit content
	Explicit bool `json:"explicit"`

	// ExternalLinks Represents available links to something that is related to a catalog item, but external to the TIDAL API
	ExternalLinks *[]CatalogueItemExternalLink `json:"externalLinks,omitempty"`

	// Isrc ISRC code
	Isrc      string   `json:"isrc"`
	MediaTags []string `json:"mediaTags"`

	// Popularity Track or video popularity (ranged in 0.00 ... 1.00). Conditionally visible
	Popularity float64 `json:"popularity"`

	// Title Album item's title
	Title string `json:"title"`

	// Version Version of the album's item; complements title
	Version *string `json:"version,omitempty"`
}

// TracksAttributesAvailability defines model for TracksAttributes.Availability.
type TracksAttributesAvailability string

// TracksRelationships defines model for Tracks_Relationships.
type TracksRelationships struct {
	Albums        MultiDataRelationshipDoc `json:"albums"`
	Artists       MultiDataRelationshipDoc `json:"artists"`
	Providers     MultiDataRelationshipDoc `json:"providers"`
	Radio         MultiDataRelationshipDoc `json:"radio"`
	SimilarTracks MultiDataRelationshipDoc `json:"similarTracks"`
}

// TracksResource defines model for Tracks_Resource.
type TracksResource struct {
	Attributes *TracksAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links               `json:"links,omitempty"`
	Relationships *TracksRelationships `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// VideoLinkMeta metadata about a video
type VideoLinkMeta struct {
	// Height video height (in pixels)
	Height int32 `json:"height"`

	// Width video width (in pixels)
	Width int32 `json:"width"`
}

// VideosAttributes defines model for Videos_Attributes.
type VideosAttributes struct {
	// Availability Defines a catalog item availability e.g. for streaming, DJs, stems
	Availability *[]VideosAttributesAvailability `json:"availability,omitempty"`

	// Copyright Copyright information
	Copyright *string `json:"copyright,omitempty"`

	// Duration Duration expressed in accordance with ISO 8601
	Duration string `json:"duration"`

	// Explicit Indicates whether a catalog item consist of any explicit content
	Explicit bool `json:"explicit"`

	// ExternalLinks Represents available links to something that is related to a catalog item, but external to the TIDAL API
	ExternalLinks *[]CatalogueItemExternalLink `json:"externalLinks,omitempty"`

	// ImageLinks Represents available links to, and metadata about, an album item images
	ImageLinks *[]CatalogueItemImageLink `json:"imageLinks,omitempty"`

	// Isrc ISRC code
	Isrc string `json:"isrc"`

	// Popularity Track or video popularity (ranged in 0.00 ... 1.00). Conditionally visible
	Popularity float64 `json:"popularity"`

	// ReleaseDate Release date (ISO-8601)
	ReleaseDate *openapi_types.Date `json:"releaseDate,omitempty"`

	// Title Album item's title
	Title string `json:"title"`

	// Version Version of the album's item; complements title
	Version *string `json:"version,omitempty"`
}

// VideosAttributesAvailability defines model for VideosAttributes.Availability.
type VideosAttributesAvailability string

// VideosRelationships defines model for Videos_Relationships.
type VideosRelationships struct {
	Albums    MultiDataRelationshipDoc `json:"albums"`
	Artists   MultiDataRelationshipDoc `json:"artists"`
	Providers MultiDataRelationshipDoc `json:"providers"`
}

// VideosResource defines model for Videos_Resource.
type VideosResource struct {
	Attributes *VideosAttributes `json:"attributes,omitempty"`

	// Id resource unique identifier
	Id string `json:"id"`

	// Links Links JSON:API object
	Links         *Links               `json:"links,omitempty"`
	Relationships *VideosRelationships `json:"relationships,omitempty"`

	// Type resource unique type
	Type string `json:"type"`
}

// GetSearchResultsByQueryParams defines parameters for GetSearchResultsByQuery.
type GetSearchResultsByQueryParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: artists, albums, tracks, videos, playlists, topHits
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`
}

// GetSearchResultsAlbumsRelationshipParams defines parameters for GetSearchResultsAlbumsRelationship.
type GetSearchResultsAlbumsRelationshipParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: albums
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// PageCursor Server-generated cursor value pointing a certain page of items. Optional, targets first page if not specified
	PageCursor *string `form:"page[cursor],omitempty" json:"page[cursor],omitempty"`
}

// GetSearchResultsArtistsRelationshipParams defines parameters for GetSearchResultsArtistsRelationship.
type GetSearchResultsArtistsRelationshipParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: artists
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// PageCursor Server-generated cursor value pointing a certain page of items. Optional, targets first page if not specified
	PageCursor *string `form:"page[cursor],omitempty" json:"page[cursor],omitempty"`
}

// GetSearchResultsPlaylistsRelationshipParams defines parameters for GetSearchResultsPlaylistsRelationship.
type GetSearchResultsPlaylistsRelationshipParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: playlists
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// PageCursor Server-generated cursor value pointing a certain page of items. Optional, targets first page if not specified
	PageCursor *string `form:"page[cursor],omitempty" json:"page[cursor],omitempty"`
}

// GetSearchResultsTopHitsRelationshipParams defines parameters for GetSearchResultsTopHitsRelationship.
type GetSearchResultsTopHitsRelationshipParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: topHits
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// PageCursor Server-generated cursor value pointing a certain page of items. Optional, targets first page if not specified
	PageCursor *string `form:"page[cursor],omitempty" json:"page[cursor],omitempty"`
}

// GetSearchResultsTracksRelationshipParams defines parameters for GetSearchResultsTracksRelationship.
type GetSearchResultsTracksRelationshipParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: tracks
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// PageCursor Server-generated cursor value pointing a certain page of items. Optional, targets first page if not specified
	PageCursor *string `form:"page[cursor],omitempty" json:"page[cursor],omitempty"`
}

// GetSearchResultsVideosRelationshipParams defines parameters for GetSearchResultsVideosRelationship.
type GetSearchResultsVideosRelationshipParams struct {
	// CountryCode ISO 3166-1 alpha-2 country code
	CountryCode string `form:"countryCode" json:"countryCode"`

	// Include Allows the client to customize which related resources should be returned. Available options: videos
	Include *[]string `form:"include,omitempty" json:"include,omitempty"`

	// PageCursor Server-generated cursor value pointing a certain page of items. Optional, targets first page if not specified
	PageCursor *string `form:"page[cursor],omitempty" json:"page[cursor],omitempty"`
}

// AsArtistsResource returns the union data inside the SearchresultsMultiDataDocument_Included_Item as a ArtistsResource
func (t SearchresultsMultiDataDocument_Included_Item) AsArtistsResource() (ArtistsResource, error) {
	var body ArtistsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistsResource overwrites any union data inside the SearchresultsMultiDataDocument_Included_Item as the provided ArtistsResource
func (t *SearchresultsMultiDataDocument_Included_Item) FromArtistsResource(v ArtistsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistsResource performs a merge with any union data inside the SearchresultsMultiDataDocument_Included_Item, using the provided ArtistsResource
func (t *SearchresultsMultiDataDocument_Included_Item) MergeArtistsResource(v ArtistsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaylistsResource returns the union data inside the SearchresultsMultiDataDocument_Included_Item as a PlaylistsResource
func (t SearchresultsMultiDataDocument_Included_Item) AsPlaylistsResource() (PlaylistsResource, error) {
	var body PlaylistsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaylistsResource overwrites any union data inside the SearchresultsMultiDataDocument_Included_Item as the provided PlaylistsResource
func (t *SearchresultsMultiDataDocument_Included_Item) FromPlaylistsResource(v PlaylistsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaylistsResource performs a merge with any union data inside the SearchresultsMultiDataDocument_Included_Item, using the provided PlaylistsResource
func (t *SearchresultsMultiDataDocument_Included_Item) MergePlaylistsResource(v PlaylistsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideosResource returns the union data inside the SearchresultsMultiDataDocument_Included_Item as a VideosResource
func (t SearchresultsMultiDataDocument_Included_Item) AsVideosResource() (VideosResource, error) {
	var body VideosResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideosResource overwrites any union data inside the SearchresultsMultiDataDocument_Included_Item as the provided VideosResource
func (t *SearchresultsMultiDataDocument_Included_Item) FromVideosResource(v VideosResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideosResource performs a merge with any union data inside the SearchresultsMultiDataDocument_Included_Item, using the provided VideosResource
func (t *SearchresultsMultiDataDocument_Included_Item) MergeVideosResource(v VideosResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAlbumsResource returns the union data inside the SearchresultsMultiDataDocument_Included_Item as a AlbumsResource
func (t SearchresultsMultiDataDocument_Included_Item) AsAlbumsResource() (AlbumsResource, error) {
	var body AlbumsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlbumsResource overwrites any union data inside the SearchresultsMultiDataDocument_Included_Item as the provided AlbumsResource
func (t *SearchresultsMultiDataDocument_Included_Item) FromAlbumsResource(v AlbumsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlbumsResource performs a merge with any union data inside the SearchresultsMultiDataDocument_Included_Item, using the provided AlbumsResource
func (t *SearchresultsMultiDataDocument_Included_Item) MergeAlbumsResource(v AlbumsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTracksResource returns the union data inside the SearchresultsMultiDataDocument_Included_Item as a TracksResource
func (t SearchresultsMultiDataDocument_Included_Item) AsTracksResource() (TracksResource, error) {
	var body TracksResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTracksResource overwrites any union data inside the SearchresultsMultiDataDocument_Included_Item as the provided TracksResource
func (t *SearchresultsMultiDataDocument_Included_Item) FromTracksResource(v TracksResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTracksResource performs a merge with any union data inside the SearchresultsMultiDataDocument_Included_Item, using the provided TracksResource
func (t *SearchresultsMultiDataDocument_Included_Item) MergeTracksResource(v TracksResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchresultsMultiDataDocument_Included_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchresultsMultiDataDocument_Included_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsArtistsResource returns the union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as a ArtistsResource
func (t SearchresultsMultiDataRelationshipDocument_Included_Item) AsArtistsResource() (ArtistsResource, error) {
	var body ArtistsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistsResource overwrites any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as the provided ArtistsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) FromArtistsResource(v ArtistsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistsResource performs a merge with any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item, using the provided ArtistsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) MergeArtistsResource(v ArtistsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaylistsResource returns the union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as a PlaylistsResource
func (t SearchresultsMultiDataRelationshipDocument_Included_Item) AsPlaylistsResource() (PlaylistsResource, error) {
	var body PlaylistsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaylistsResource overwrites any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as the provided PlaylistsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) FromPlaylistsResource(v PlaylistsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaylistsResource performs a merge with any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item, using the provided PlaylistsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) MergePlaylistsResource(v PlaylistsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideosResource returns the union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as a VideosResource
func (t SearchresultsMultiDataRelationshipDocument_Included_Item) AsVideosResource() (VideosResource, error) {
	var body VideosResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideosResource overwrites any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as the provided VideosResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) FromVideosResource(v VideosResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideosResource performs a merge with any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item, using the provided VideosResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) MergeVideosResource(v VideosResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAlbumsResource returns the union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as a AlbumsResource
func (t SearchresultsMultiDataRelationshipDocument_Included_Item) AsAlbumsResource() (AlbumsResource, error) {
	var body AlbumsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlbumsResource overwrites any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as the provided AlbumsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) FromAlbumsResource(v AlbumsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlbumsResource performs a merge with any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item, using the provided AlbumsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) MergeAlbumsResource(v AlbumsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTracksResource returns the union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as a TracksResource
func (t SearchresultsMultiDataRelationshipDocument_Included_Item) AsTracksResource() (TracksResource, error) {
	var body TracksResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTracksResource overwrites any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as the provided TracksResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) FromTracksResource(v TracksResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTracksResource performs a merge with any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item, using the provided TracksResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) MergeTracksResource(v TracksResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsSearchresultsResource returns the union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as a SearchresultsResource
func (t SearchresultsMultiDataRelationshipDocument_Included_Item) AsSearchresultsResource() (SearchresultsResource, error) {
	var body SearchresultsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromSearchresultsResource overwrites any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item as the provided SearchresultsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) FromSearchresultsResource(v SearchresultsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeSearchresultsResource performs a merge with any union data inside the SearchresultsMultiDataRelationshipDocument_Included_Item, using the provided SearchresultsResource
func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) MergeSearchresultsResource(v SearchresultsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchresultsMultiDataRelationshipDocument_Included_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchresultsMultiDataRelationshipDocument_Included_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsArtistsResource returns the union data inside the SearchresultsSingleDataDocument_Included_Item as a ArtistsResource
func (t SearchresultsSingleDataDocument_Included_Item) AsArtistsResource() (ArtistsResource, error) {
	var body ArtistsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromArtistsResource overwrites any union data inside the SearchresultsSingleDataDocument_Included_Item as the provided ArtistsResource
func (t *SearchresultsSingleDataDocument_Included_Item) FromArtistsResource(v ArtistsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeArtistsResource performs a merge with any union data inside the SearchresultsSingleDataDocument_Included_Item, using the provided ArtistsResource
func (t *SearchresultsSingleDataDocument_Included_Item) MergeArtistsResource(v ArtistsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaylistsResource returns the union data inside the SearchresultsSingleDataDocument_Included_Item as a PlaylistsResource
func (t SearchresultsSingleDataDocument_Included_Item) AsPlaylistsResource() (PlaylistsResource, error) {
	var body PlaylistsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaylistsResource overwrites any union data inside the SearchresultsSingleDataDocument_Included_Item as the provided PlaylistsResource
func (t *SearchresultsSingleDataDocument_Included_Item) FromPlaylistsResource(v PlaylistsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaylistsResource performs a merge with any union data inside the SearchresultsSingleDataDocument_Included_Item, using the provided PlaylistsResource
func (t *SearchresultsSingleDataDocument_Included_Item) MergePlaylistsResource(v PlaylistsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsVideosResource returns the union data inside the SearchresultsSingleDataDocument_Included_Item as a VideosResource
func (t SearchresultsSingleDataDocument_Included_Item) AsVideosResource() (VideosResource, error) {
	var body VideosResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromVideosResource overwrites any union data inside the SearchresultsSingleDataDocument_Included_Item as the provided VideosResource
func (t *SearchresultsSingleDataDocument_Included_Item) FromVideosResource(v VideosResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeVideosResource performs a merge with any union data inside the SearchresultsSingleDataDocument_Included_Item, using the provided VideosResource
func (t *SearchresultsSingleDataDocument_Included_Item) MergeVideosResource(v VideosResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsAlbumsResource returns the union data inside the SearchresultsSingleDataDocument_Included_Item as a AlbumsResource
func (t SearchresultsSingleDataDocument_Included_Item) AsAlbumsResource() (AlbumsResource, error) {
	var body AlbumsResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromAlbumsResource overwrites any union data inside the SearchresultsSingleDataDocument_Included_Item as the provided AlbumsResource
func (t *SearchresultsSingleDataDocument_Included_Item) FromAlbumsResource(v AlbumsResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeAlbumsResource performs a merge with any union data inside the SearchresultsSingleDataDocument_Included_Item, using the provided AlbumsResource
func (t *SearchresultsSingleDataDocument_Included_Item) MergeAlbumsResource(v AlbumsResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsTracksResource returns the union data inside the SearchresultsSingleDataDocument_Included_Item as a TracksResource
func (t SearchresultsSingleDataDocument_Included_Item) AsTracksResource() (TracksResource, error) {
	var body TracksResource
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTracksResource overwrites any union data inside the SearchresultsSingleDataDocument_Included_Item as the provided TracksResource
func (t *SearchresultsSingleDataDocument_Included_Item) FromTracksResource(v TracksResource) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTracksResource performs a merge with any union data inside the SearchresultsSingleDataDocument_Included_Item, using the provided TracksResource
func (t *SearchresultsSingleDataDocument_Included_Item) MergeTracksResource(v TracksResource) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t SearchresultsSingleDataDocument_Included_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *SearchresultsSingleDataDocument_Included_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetSearchResultsByQuery request
	GetSearchResultsByQuery(ctx context.Context, query string, params *GetSearchResultsByQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsAlbumsRelationship request
	GetSearchResultsAlbumsRelationship(ctx context.Context, query string, params *GetSearchResultsAlbumsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsArtistsRelationship request
	GetSearchResultsArtistsRelationship(ctx context.Context, query string, params *GetSearchResultsArtistsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsPlaylistsRelationship request
	GetSearchResultsPlaylistsRelationship(ctx context.Context, query string, params *GetSearchResultsPlaylistsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsTopHitsRelationship request
	GetSearchResultsTopHitsRelationship(ctx context.Context, query string, params *GetSearchResultsTopHitsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsTracksRelationship request
	GetSearchResultsTracksRelationship(ctx context.Context, query string, params *GetSearchResultsTracksRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchResultsVideosRelationship request
	GetSearchResultsVideosRelationship(ctx context.Context, query string, params *GetSearchResultsVideosRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetSearchResultsByQuery(ctx context.Context, query string, params *GetSearchResultsByQueryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsByQueryRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsAlbumsRelationship(ctx context.Context, query string, params *GetSearchResultsAlbumsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsAlbumsRelationshipRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsArtistsRelationship(ctx context.Context, query string, params *GetSearchResultsArtistsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsArtistsRelationshipRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsPlaylistsRelationship(ctx context.Context, query string, params *GetSearchResultsPlaylistsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsPlaylistsRelationshipRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsTopHitsRelationship(ctx context.Context, query string, params *GetSearchResultsTopHitsRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsTopHitsRelationshipRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsTracksRelationship(ctx context.Context, query string, params *GetSearchResultsTracksRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsTracksRelationshipRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchResultsVideosRelationship(ctx context.Context, query string, params *GetSearchResultsVideosRelationshipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchResultsVideosRelationshipRequest(c.Server, query, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetSearchResultsByQueryRequest generates requests for GetSearchResultsByQuery
func NewGetSearchResultsByQueryRequest(server string, query string, params *GetSearchResultsByQueryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsAlbumsRelationshipRequest generates requests for GetSearchResultsAlbumsRelationship
func NewGetSearchResultsAlbumsRelationshipRequest(server string, query string, params *GetSearchResultsAlbumsRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s/relationships/albums", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[cursor]", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsArtistsRelationshipRequest generates requests for GetSearchResultsArtistsRelationship
func NewGetSearchResultsArtistsRelationshipRequest(server string, query string, params *GetSearchResultsArtistsRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s/relationships/artists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[cursor]", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsPlaylistsRelationshipRequest generates requests for GetSearchResultsPlaylistsRelationship
func NewGetSearchResultsPlaylistsRelationshipRequest(server string, query string, params *GetSearchResultsPlaylistsRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s/relationships/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[cursor]", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsTopHitsRelationshipRequest generates requests for GetSearchResultsTopHitsRelationship
func NewGetSearchResultsTopHitsRelationshipRequest(server string, query string, params *GetSearchResultsTopHitsRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s/relationships/topHits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[cursor]", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsTracksRelationshipRequest generates requests for GetSearchResultsTracksRelationship
func NewGetSearchResultsTracksRelationshipRequest(server string, query string, params *GetSearchResultsTracksRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s/relationships/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[cursor]", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSearchResultsVideosRelationshipRequest generates requests for GetSearchResultsVideosRelationship
func NewGetSearchResultsVideosRelationshipRequest(server string, query string, params *GetSearchResultsVideosRelationshipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "query", runtime.ParamLocationPath, query)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/searchresults/%s/relationships/videos", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "countryCode", runtime.ParamLocationQuery, params.CountryCode); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Include != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include", runtime.ParamLocationQuery, *params.Include); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PageCursor != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[cursor]", runtime.ParamLocationQuery, *params.PageCursor); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetSearchResultsByQueryWithResponse request
	GetSearchResultsByQueryWithResponse(ctx context.Context, query string, params *GetSearchResultsByQueryParams, reqEditors ...RequestEditorFn) (*GetSearchResultsByQueryResponse, error)

	// GetSearchResultsAlbumsRelationshipWithResponse request
	GetSearchResultsAlbumsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsAlbumsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsAlbumsRelationshipResponse, error)

	// GetSearchResultsArtistsRelationshipWithResponse request
	GetSearchResultsArtistsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsArtistsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsArtistsRelationshipResponse, error)

	// GetSearchResultsPlaylistsRelationshipWithResponse request
	GetSearchResultsPlaylistsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsPlaylistsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsPlaylistsRelationshipResponse, error)

	// GetSearchResultsTopHitsRelationshipWithResponse request
	GetSearchResultsTopHitsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsTopHitsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsTopHitsRelationshipResponse, error)

	// GetSearchResultsTracksRelationshipWithResponse request
	GetSearchResultsTracksRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsTracksRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsTracksRelationshipResponse, error)

	// GetSearchResultsVideosRelationshipWithResponse request
	GetSearchResultsVideosRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsVideosRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsVideosRelationshipResponse, error)
}

type GetSearchResultsByQueryResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsSingleDataDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsByQueryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsByQueryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsAlbumsRelationshipResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsMultiDataRelationshipDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsAlbumsRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsAlbumsRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsArtistsRelationshipResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsMultiDataRelationshipDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsArtistsRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsArtistsRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsPlaylistsRelationshipResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsMultiDataRelationshipDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsPlaylistsRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsPlaylistsRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsTopHitsRelationshipResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsMultiDataRelationshipDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsTopHitsRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsTopHitsRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsTracksRelationshipResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsMultiDataRelationshipDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsTracksRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsTracksRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchResultsVideosRelationshipResponse struct {
	Body                     []byte
	HTTPResponse             *http.Response
	ApplicationvndApiJSON200 *SearchresultsMultiDataRelationshipDocument
	ApplicationvndApiJSON400 *ErrorDocument
	ApplicationvndApiJSON404 *ErrorDocument
	ApplicationvndApiJSON405 *ErrorDocument
	ApplicationvndApiJSON406 *ErrorDocument
	ApplicationvndApiJSON415 *ErrorDocument
	ApplicationvndApiJSON500 *ErrorDocument
}

// Status returns HTTPResponse.Status
func (r GetSearchResultsVideosRelationshipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchResultsVideosRelationshipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetSearchResultsByQueryWithResponse request returning *GetSearchResultsByQueryResponse
func (c *ClientWithResponses) GetSearchResultsByQueryWithResponse(ctx context.Context, query string, params *GetSearchResultsByQueryParams, reqEditors ...RequestEditorFn) (*GetSearchResultsByQueryResponse, error) {
	rsp, err := c.GetSearchResultsByQuery(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsByQueryResponse(rsp)
}

// GetSearchResultsAlbumsRelationshipWithResponse request returning *GetSearchResultsAlbumsRelationshipResponse
func (c *ClientWithResponses) GetSearchResultsAlbumsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsAlbumsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsAlbumsRelationshipResponse, error) {
	rsp, err := c.GetSearchResultsAlbumsRelationship(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsAlbumsRelationshipResponse(rsp)
}

// GetSearchResultsArtistsRelationshipWithResponse request returning *GetSearchResultsArtistsRelationshipResponse
func (c *ClientWithResponses) GetSearchResultsArtistsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsArtistsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsArtistsRelationshipResponse, error) {
	rsp, err := c.GetSearchResultsArtistsRelationship(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsArtistsRelationshipResponse(rsp)
}

// GetSearchResultsPlaylistsRelationshipWithResponse request returning *GetSearchResultsPlaylistsRelationshipResponse
func (c *ClientWithResponses) GetSearchResultsPlaylistsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsPlaylistsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsPlaylistsRelationshipResponse, error) {
	rsp, err := c.GetSearchResultsPlaylistsRelationship(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsPlaylistsRelationshipResponse(rsp)
}

// GetSearchResultsTopHitsRelationshipWithResponse request returning *GetSearchResultsTopHitsRelationshipResponse
func (c *ClientWithResponses) GetSearchResultsTopHitsRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsTopHitsRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsTopHitsRelationshipResponse, error) {
	rsp, err := c.GetSearchResultsTopHitsRelationship(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsTopHitsRelationshipResponse(rsp)
}

// GetSearchResultsTracksRelationshipWithResponse request returning *GetSearchResultsTracksRelationshipResponse
func (c *ClientWithResponses) GetSearchResultsTracksRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsTracksRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsTracksRelationshipResponse, error) {
	rsp, err := c.GetSearchResultsTracksRelationship(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsTracksRelationshipResponse(rsp)
}

// GetSearchResultsVideosRelationshipWithResponse request returning *GetSearchResultsVideosRelationshipResponse
func (c *ClientWithResponses) GetSearchResultsVideosRelationshipWithResponse(ctx context.Context, query string, params *GetSearchResultsVideosRelationshipParams, reqEditors ...RequestEditorFn) (*GetSearchResultsVideosRelationshipResponse, error) {
	rsp, err := c.GetSearchResultsVideosRelationship(ctx, query, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchResultsVideosRelationshipResponse(rsp)
}

// ParseGetSearchResultsByQueryResponse parses an HTTP response from a GetSearchResultsByQueryWithResponse call
func ParseGetSearchResultsByQueryResponse(rsp *http.Response) (*GetSearchResultsByQueryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsByQueryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsSingleDataDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsAlbumsRelationshipResponse parses an HTTP response from a GetSearchResultsAlbumsRelationshipWithResponse call
func ParseGetSearchResultsAlbumsRelationshipResponse(rsp *http.Response) (*GetSearchResultsAlbumsRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsAlbumsRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsMultiDataRelationshipDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsArtistsRelationshipResponse parses an HTTP response from a GetSearchResultsArtistsRelationshipWithResponse call
func ParseGetSearchResultsArtistsRelationshipResponse(rsp *http.Response) (*GetSearchResultsArtistsRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsArtistsRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsMultiDataRelationshipDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsPlaylistsRelationshipResponse parses an HTTP response from a GetSearchResultsPlaylistsRelationshipWithResponse call
func ParseGetSearchResultsPlaylistsRelationshipResponse(rsp *http.Response) (*GetSearchResultsPlaylistsRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsPlaylistsRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsMultiDataRelationshipDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsTopHitsRelationshipResponse parses an HTTP response from a GetSearchResultsTopHitsRelationshipWithResponse call
func ParseGetSearchResultsTopHitsRelationshipResponse(rsp *http.Response) (*GetSearchResultsTopHitsRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsTopHitsRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsMultiDataRelationshipDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsTracksRelationshipResponse parses an HTTP response from a GetSearchResultsTracksRelationshipWithResponse call
func ParseGetSearchResultsTracksRelationshipResponse(rsp *http.Response) (*GetSearchResultsTracksRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsTracksRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsMultiDataRelationshipDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}

// ParseGetSearchResultsVideosRelationshipResponse parses an HTTP response from a GetSearchResultsVideosRelationshipWithResponse call
func ParseGetSearchResultsVideosRelationshipResponse(rsp *http.Response) (*GetSearchResultsVideosRelationshipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchResultsVideosRelationshipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SearchresultsMultiDataRelationshipDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 405:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON405 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 406:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON406 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 415:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON415 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ErrorDocument
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationvndApiJSON500 = &dest

	}

	return response, nil
}
